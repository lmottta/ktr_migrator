#!/usr/bin/env python3
"""
KTR Migrator - CLI Interface
Ferramenta para migra√ß√£o de pipelines Pentaho KTR para Python

Usage:
    ktr-migrator convert <ktr_file> --output <output_dir>
    ktr-migrator analyze <ktr_file> [--report <report_file>]
    ktr-migrator batch-convert <input_dir> --output <output_dir>
    ktr-migrator validate <ktr_file>
"""

import click
import os
import sys
from pathlib import Path
from typing import List
from loguru import logger
import json

# Adicionar src ao path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from src.parser.ktr_parser import KTRParser
from src.generator.code_generator import CodeGenerator
from src.analyzer.pipeline_analyzer import PipelineAnalyzer

@click.group()
@click.version_option(version="1.0.0")
def cli():
    """üîÑ KTR Migrator - Migra√ß√£o de pipelines Pentaho para Python"""
    setup_logging()

def setup_logging():
    """Configura logging global"""
    logger.remove()  # Remove handler padr√£o
    logger.add(
        sys.stderr,
        format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{message}</cyan>",
        level="INFO"
    )
    logger.add(
        "logs/ktr_migrator.log",
        rotation="1 MB",
        retention="7 days",
        format="{time} | {level} | {message}",
        level="DEBUG"
    )

@cli.command()
@click.argument('ktr_file', type=click.Path(exists=True))
@click.option('--output', '-o', required=True, help='Diret√≥rio de sa√≠da')
@click.option('--optimize', is_flag=True, help='Aplicar otimiza√ß√µes avan√ßadas')
@click.option('--format-code', is_flag=True, default=True, help='Formatar c√≥digo gerado')
@click.option('--generate-tests', is_flag=True, default=True, help='Gerar testes automatizados')
def convert(ktr_file: str, output: str, optimize: bool, format_code: bool, generate_tests: bool):
    """
    üîÑ Converte um arquivo KTR para pipeline Python
    
    \b
    Exemplo:
        ktr-migrator convert exemplo.ktr --output ./pipeline_python/
    """
    logger.info(f"üöÄ Iniciando convers√£o: {ktr_file}")
    
    try:
        # Parse do KTR
        parser = KTRParser()
        ktr_model = parser.parse_file(ktr_file)
        
        # An√°lise (se otimiza√ß√£o habilitada)
        if optimize:
            analyzer = PipelineAnalyzer()
            analysis = analyzer.analyze_pipeline(ktr_model)
            logger.info(f"üìä An√°lise completa: {analysis.complexity_score} pontos")
        
        # Gera√ß√£o do c√≥digo
        generator = CodeGenerator()
        project = generator.generate_pipeline(ktr_model, output)
        
        # P√≥s-processamento
        if format_code:
            _format_generated_code(project)
        
        # Relat√≥rio de sucesso
        _print_conversion_report(ktr_file, project)
        
        logger.info(f"‚úÖ Convers√£o conclu√≠da com sucesso!")
        logger.info(f"üìÅ Projeto gerado em: {output}")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na convers√£o: {e}")
        sys.exit(1)

@cli.command()
@click.argument('ktr_file', type=click.Path(exists=True))
@click.option('--report', '-r', help='Arquivo de relat√≥rio (HTML/JSON)')
@click.option('--format', 'report_format', type=click.Choice(['json', 'html', 'text']), default='text')
def analyze(ktr_file: str, report: str, report_format: str):
    """
    üîç Analisa um arquivo KTR sem gerar c√≥digo
    
    \b
    Exemplo:
        ktr-migrator analyze exemplo.ktr --report relatorio.html --format html
    """
    logger.info(f"üîç Analisando arquivo: {ktr_file}")
    
    try:
        # Parse do KTR
        parser = KTRParser()
        ktr_model = parser.parse_file(ktr_file)
        
        # An√°lise detalhada
        analyzer = PipelineAnalyzer()
        analysis = analyzer.analyze_pipeline(ktr_model)
        
        # Gerar relat√≥rio
        if report:
            _generate_analysis_report(analysis, report, report_format)
        else:
            _print_analysis_summary(analysis)
        
        logger.info("‚úÖ An√°lise conclu√≠da!")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na an√°lise: {e}")
        sys.exit(1)

@cli.command()
@click.argument('input_dir', type=click.Path(exists=True))
@click.option('--output', '-o', required=True, help='Diret√≥rio base de sa√≠da')
@click.option('--pattern', default='*.ktr', help='Padr√£o de arquivos (ex: *.ktr)')
@click.option('--optimize', is_flag=True, help='Aplicar otimiza√ß√µes')
def batch_convert(input_dir: str, output: str, pattern: str, optimize: bool):
    """
    üì¶ Converte m√∫ltiplos arquivos KTR em lote
    
    \b
    Exemplo:
        ktr-migrator batch-convert ./ktr_files/ --output ./python_pipelines/
    """
    logger.info(f"üì¶ Convers√£o em lote: {input_dir}")
    
    input_path = Path(input_dir)
    ktr_files = list(input_path.glob(pattern))
    
    if not ktr_files:
        logger.warning(f"‚ö†Ô∏è Nenhum arquivo encontrado com padr√£o: {pattern}")
        return
    
    logger.info(f"üìÅ {len(ktr_files)} arquivos encontrados")
    
    success_count = 0
    error_count = 0
    
    for ktr_file in ktr_files:
        try:
            logger.info(f"üîÑ Processando: {ktr_file.name}")
            
            # Parse e gera√ß√£o
            parser = KTRParser()
            ktr_model = parser.parse_file(str(ktr_file))
            
            # Diret√≥rio espec√≠fico para este pipeline
            pipeline_output = Path(output) / ktr_model.name
            
            generator = CodeGenerator()
            project = generator.generate_pipeline(ktr_model, str(pipeline_output))
            
            success_count += 1
            logger.info(f"‚úÖ {ktr_file.name} convertido")
            
        except Exception as e:
            error_count += 1
            logger.error(f"‚ùå Erro em {ktr_file.name}: {e}")
            continue
    
    # Relat√≥rio final
    logger.info(f"üìä Convers√£o em lote conclu√≠da:")
    logger.info(f"   ‚úÖ Sucessos: {success_count}")
    logger.info(f"   ‚ùå Erros: {error_count}")
    logger.info(f"   üìÅ Sa√≠da: {output}")

@cli.command()
@click.argument('ktr_file', type=click.Path(exists=True))
def validate(ktr_file: str):
    """
    ‚úÖ Valida a estrutura de um arquivo KTR
    
    \b
    Exemplo:
        ktr-migrator validate exemplo.ktr
    """
    logger.info(f"‚úÖ Validando arquivo: {ktr_file}")
    
    try:
        parser = KTRParser()
        ktr_model = parser.parse_file(ktr_file)
        
        # Valida√ß√µes b√°sicas
        issues = []
        
        if not ktr_model.connections:
            issues.append("‚ö†Ô∏è Nenhuma conex√£o definida")
        
        if not ktr_model.steps:
            issues.append("‚ùå Nenhum step encontrado")
        
        if not ktr_model.hops:
            issues.append("‚ö†Ô∏è Nenhum hop (conex√£o entre steps) encontrado")
        
        # Validar integridade dos hops
        step_names = {step.name for step in ktr_model.steps}
        for hop in ktr_model.hops:
            if hop.from_step not in step_names:
                issues.append(f"‚ùå Hop inv√°lido: step '{hop.from_step}' n√£o existe")
            if hop.to_step not in step_names:
                issues.append(f"‚ùå Hop inv√°lido: step '{hop.to_step}' n√£o existe")
        
        # Relat√≥rio de valida√ß√£o
        if issues:
            logger.warning("‚ö†Ô∏è Issues encontrados:")
            for issue in issues:
                click.echo(f"  {issue}")
        else:
            logger.info("‚úÖ KTR v√°lido!")
            
        # Estat√≠sticas
        click.echo(f"\nüìä Estat√≠sticas:")
        click.echo(f"  üì° Conex√µes: {len(ktr_model.connections)}")
        click.echo(f"  üîß Steps: {len(ktr_model.steps)}")
        click.echo(f"  üîó Hops: {len(ktr_model.hops)}")
        
        # Breakdown por tipo de step
        input_steps = len([s for s in ktr_model.steps if s.is_input])
        transform_steps = len([s for s in ktr_model.steps if s.is_transform])
        output_steps = len([s for s in ktr_model.steps if s.is_output])
        
        click.echo(f"     üì• Input: {input_steps}")
        click.echo(f"     ‚öôÔ∏è Transform: {transform_steps}")
        click.echo(f"     üì§ Output: {output_steps}")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na valida√ß√£o: {e}")
        sys.exit(1)

@cli.command()
@click.argument('ktr_file', type=click.Path(exists=True))
def preview(ktr_file: str):
    """
    üëÄ Preview do c√≥digo que seria gerado (sem criar arquivos)
    
    \b
    Exemplo:
        ktr-migrator preview exemplo.ktr
    """
    logger.info(f"üëÄ Preview de: {ktr_file}")
    
    try:
        # Parse do KTR
        parser = KTRParser()
        ktr_model = parser.parse_file(ktr_file)
        
        # Gerar apenas template principal
        generator = CodeGenerator()
        template_data = generator._prepare_template_data(ktr_model)
        main_pipeline = generator._generate_main_pipeline(template_data)
        
        click.echo("üêç C√≥digo Python que seria gerado:")
        click.echo("=" * 60)
        click.echo(main_pipeline[:2000])  # Primeiras 2000 chars
        
        if len(main_pipeline) > 2000:
            click.echo("\n... (c√≥digo truncado)")
        
        click.echo("=" * 60)
        click.echo(f"üìä Total: {len(main_pipeline)} caracteres")
        
    except Exception as e:
        logger.error(f"‚ùå Erro no preview: {e}")
        sys.exit(1)

def _format_generated_code(project):
    """Formata c√≥digo gerado usando black"""
    try:
        import subprocess
        
        for file_path, content in project.files.items():
            if file_path.endswith('.py'):
                full_path = Path(project.base_path) / file_path
                subprocess.run(['black', str(full_path)], capture_output=True)
        
        logger.info("üé® C√≥digo formatado com black")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel formatar c√≥digo: {e}")

def _print_conversion_report(ktr_file: str, project):
    """Imprime relat√≥rio de convers√£o"""
    click.echo("\n" + "=" * 60)
    click.echo("üìã RELAT√ìRIO DE CONVERS√ÉO")
    click.echo("=" * 60)
    click.echo(f"üìÑ Arquivo origem: {ktr_file}")
    click.echo(f"üìÅ Projeto destino: {project.base_path}")
    click.echo(f"üêç Pipeline: {project.name}")
    click.echo(f"üì¶ Depend√™ncias: {', '.join(project.dependencies)}")
    click.echo(f"üìÑ Arquivos gerados: {len(project.files)}")
    
    click.echo("\nüìÅ Estrutura criada:")
    for file_path in sorted(project.files.keys()):
        click.echo(f"  üìÑ {file_path}")
    
    click.echo("\nüöÄ Pr√≥ximos passos:")
    click.echo(f"  1. cd {project.base_path}")
    click.echo(f"  2. pip install -r requirements.txt")
    click.echo(f"  3. cp .env.example .env")
    click.echo(f"  4. python src/pipelines/{project.name.lower()}_pipeline.py")

def _generate_analysis_report(analysis, report_file: str, format_type: str):
    """Gera relat√≥rio de an√°lise"""
    if format_type == 'json':
        with open(report_file, 'w') as f:
            json.dump(analysis.to_dict(), f, indent=2)
    elif format_type == 'html':
        # Implementar gera√ß√£o HTML
        pass
    else:  # text
        with open(report_file, 'w') as f:
            f.write(f"Relat√≥rio de An√°lise KTR\n")
            f.write(f"=" * 30 + "\n\n")
            f.write(f"Complexidade: {analysis.complexity_score}\n")
            # Adicionar mais detalhes...

def _print_analysis_summary(analysis):
    """Imprime resumo da an√°lise"""
    click.echo("\nüìä AN√ÅLISE DO PIPELINE")
    click.echo("=" * 30)
    click.echo(f"üéØ Complexidade: {analysis.complexity_score}/100")
    click.echo(f"‚ö° Performance estimada: {analysis.estimated_performance_gain}%")
    click.echo(f"üîß Otimiza√ß√µes sugeridas: {len(analysis.optimizations)}")

if __name__ == '__main__':
    cli() 